# A more complex state, debugging react apps

## Complex State
```javascript
const [clicks, setClicks] = useState({
    left: 0, right: 0
  })

//when updating right click counter:
const handleRightClick = () => {
  const newClicks = { 
    ...clicks, 
    right: clicks.right + 1 
  }
  setClicks(newClicks)
}
```

### Updating complex state

1. Copy previous object
2. Update required property
3. Set new state

## State updates are asynchronous

* React waits until all code in event handlers has run before processing state updates.

* Multiple state variables can be updated without triggering too many re-renders.

## Functions that return functions

```javascript
//useful for parametrizing functionality
const App = () => {
  const [value, setValue] = useState(10)


  const hello = (who) => {
    const handler = () => {
      console.log('hello', who)
    }
    return handler
  }

  return (
    <div>
      {value}

      <button onClick={hello('world')}>button</button>
      <button onClick={hello('react')}>button</button>
      <button onClick={hello('function')}>button</button>
    </div>
  )
}
```

<details><summary><b>REMINDERS</b></summary>

> It is `FORBIDDEN` to mutate state directly, changing state should always be done by setting the state to a `NEW` object

> Setting state does `NOT` change state variables in the existing render, but requests a new render.

> `batching`: React processes state update after event handlers have finished running.

> `updater funcitons` can be used to update state multiple times in one event [1].

> `DO NOT` implement components inside other components, it hampers optimization since they are treated as a new component in every render.
</details>

## Relevant Material

1. [Queueing a Series of State Updates - React docs](https://react.dev/learn/queueing-a-series-of-state-updates)


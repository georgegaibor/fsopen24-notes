# Component state, event handlers


## Direct prop destructuring in React

```javascript
const Hello = ({ name, age }) => {
  const bornYear = () => new Date().getFullYear() - age

  return (
    <div>
      <p>
        Hello {name}, you are {age} years old
      </p>
      <p>So you were probably born in {bornYear()}</p>
    </div>
  )
}
```

## Stateful component

> Components often need to change what's on screen as a result of an interaction. In React, this kind of component specific memory is called `state`

### useState

```javascript
import { useState } from 'react'

const App = () => {
  const [ counter, setCounter ] = useState(0)

  setTimeout(
    () => setCounter(counter + 1),
    1000
  )

  return (
    <div>{counter}</div>
  )
}
```

* `useState` react hook used to declare a state variable
* `initialState` parameter for initial state value, it can be of any type

`useState` returns an array with the following state variables:

* `state` current state that matches initial value on first render
* `setState` function that allows for state updates that trigger re-renders

<details><summary><b>REMINDERS</b></summary>

> Hooks can only be called at the top level of a component

> `DO NOT` call Hooks inside loops or conditions

> `setState` functions do not have a return value and only update the state for the next render

</details>

## Event Handling

* Functions that trigger in response to `interactions` like clicking, hovering, focusing form inputs, etc.

* React lets you add event handlers to the JSX.

## Adding an event handler

```javascript
export default function Button() {
  function handleClick() { //1. Declare handler function
    alert('You clicked me!'); //2. Define function logic
  }

  return (// 3. Pass function to onClick in the button's JSX
    <button onClick={handleClick}>
      Click me
    </button>
  );
}
```

<details><summary><b>REMINDERS</b></summary>

> Event handlers are defined iniside components, so they can access props

> Parents can pass down event handlers

> Events propagate upwards. `e.stopPropagation()` can prevent it.

> `e.preventDefault()` gets rid of unwanted default browser behavior

> Calling an event handler prop from a child handler is a good alternative to propagation

</details>

## An event handler is a function

Event handlers should `ALWAYS` be a function or a function reference, never a function call.

```javascript
//function
<button onClick={() => alert('...')}>

//function reference
<button onClick={handleClick}>	

//function call, NEVER DO THIS
<button onClick={handleClick()}>

```

## Passing state - to child components

* React components should be small and reusable

* When several components need to reflect the same data, the state should be lifted up to their closest common ancestor.

```javascript
//event handler props and function definition naming convention
onSomething={handleSomething}
```